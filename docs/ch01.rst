Opening a Window - Demo 01
==========================

Purpose
^^^^^^^

Learn how to open a window, make a black screen, and close
the window.

Basics
^^^^^^^

The device attached to a computer which displays information to the user is called a *monitor*.

The monitor is composed of a two-dimensional array of light-emitting elements, each called a *pixel*.

At a given time, each individual pixel is instructed by the computer to display
one specific color, represented within the computer as a number.
The aggregate of the colors at each pixel at one moment in time, called a *frame*,
provides a picture that has some meaning to the human user.
# In OpenGL, the bottom left pixel of a window is coordinate (0,0).  The top right is (window_width,window_height)


.. figure:: _static/monitor.png
    :align: center
    :alt: 1024x768 monitor
    :figclass: align-center

    1024x768 monitor


.. figure:: _static/monitor2.png
    :align: center
    :alt: 1920x1200 monitor
    :figclass: align-center

    1920x1200 monitor




Frames are created within the computer and sent to the monitor
at a rate over time, called the *framerate*,
measured in *Hertz*.  By updating frames quickly and at a constant rate, the computer
provides the end-user with the illusion of motion.


Code
^^^^

Import Python modules.  Python's modules are a way of distributing code
without namespace collisions


.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 21
   :lines: 21

*  sys is imported, all function calls will be written as sys.function

.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 22
   :lines: 22

*  basic operating system functions

.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 23
   :lines: 23

*  numpy is a fast math/matrix library.

.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 24
   :lines: 24

*  basic math utilities

.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 25
   :lines: 25

* here, we are importing OpenGL's submodule GL
  into the current namespace, and we can call its functions
  without the OpenGL.GL prefix



But we will not need the module's prefix to call
the functions.  I did this for uniformity
with the C++ code in the Superbible book.

.. code:: Python
   :number-lines:

   import glfw  # the windowing library


On a Python prompt, you can use tab-complete to see which functions
are defined on a module.  you can also type help(modulename) (q is
used to quit out of the pager).  help works on any object, including modules.


Opening A Window
^^^^^^^^^^^^^^^^

Desktop operating systems allow the user to run more than one
program at a time, where each program draws into a subsection of
the monitor called a window.


To create and to open a window in a cross-platform manner, this
book will call procedures provided by the widely-ported GLFW library (supporting Windows, macOS, Linux).
GLFW also provides procedures for receiving
keyboard input and for controller.


GLFW/OpenGL Initialization
^^^^^^^^^^^^^^^^^^^^^^^^^^

Initialize GLFW.


.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 29
   :lines: 29-30


If you can't create a window, quit.  Otherwise, continue


* Python note - many objects can be treating as booleans,
  and the Python keyword "not" negates it
  Python does not use brackets to show nesting.
  instead it uses whitespace.
  You probably want to find keyboard shortcuts for your editeor
  to indent/unindent.  On Emacs, I use tab


One frame is created incrementally at a time on the CPU, but the frame
is sent to the monitor
only when frame is completely drawn, and each pixel has a color.
The act of sending the frame to the monitor is called *flushing*
the frame.
Flushing takes time,
and if the call to flush were to block (meaning it would not return control
back to the call-ing procedure until the flush is complete), we would
have wasted CPU time.  To avoid this,
OpenGL has two *framebuffers* (regions of memory which will eventually
contain the full data for a frame),
only one of which is "active", or writable, at a given time.
"glfwSwapBuffers" is a non-blocking call which initiates the flushing
the current buffer, and which switches the current writable framebuffer to the
other one, thus allowing the CPU to resume.  If this doesn't make
sense right now, don't worry.


Set the version of OpenGL

OpenGL has been around a long time, and has multiple, possibly incompatible versions.


.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 32
   :lines: 32-33

*  Set the preferred version open OpenGL to be 1.4





.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 35
   :lines: 35

*  Create a 500 pixel by 500 pixel window, which the user can resize.


None is the equivalent of null.

.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 37
   :lines: 37-39


*  If GLFW cannot open the window, quit.  Unlike MC Hammer, we are quite legit, yet still
   able to quit.


.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 41
   :lines: 41


* Make the window's context current




.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 44
   :lines: 44-49

* Define an register a key handler.


Functions are first class values in Python, and are objects just
like anything else.  The can be passed as arguments, for evaluation
later



.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 51
   :lines: 51


* For every frame drawn, each pixel has a default color, set by
  calling "glClearColor". "0,0,0,1", means black "0,0,0", without
  transparency (the "1").


.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 53
   :lines: 53-56


* Don't worry about the 4 lines here.  Although they are necessary,
  we will cover them later.


The Event Loop
^^^^^^^^^^^^^^

When you pause a movie, motion stops and you see one picture.
Movies are composed of sequence of pictures, when
rendered in quick succession, provide the illusion of motion.

Interactive computer graphics are rendered the same way,
one "frame" at a time.

Render a frame, flush the complete frame to the monitor.
Unless the user closed the window, repeat indefinitely.

The color of each pixel within
the current framebuffer
is reset to a default color.

When a graphics application is executing, it is creating new
frames (pictures) at some rate (e.g. 60 frames per second).  At any given
frame, the user of the application might do something, (e.g.
move the mouse, click, type on the keyboard, close the application).

At the beginning of every frame, ask GLFW if it received one
of these events since we last asked (i.e., the previous frame).


Loop until the user closes the window

.. literalinclude:: ../src/demo01/demo.py
   :language: python
   :linenos:
   :lineno-start: 59
   :lines: 59-67

* On line 60, poll the operating system for any events, such as mouse movements,
  keyboard input, etc

* On line 62, get the size of the framebuffer.  Python
  allows the returning of multiple values
  in the form of a tuple.  Assigning
  to the variables this way is a form of "destructuring"

* On line 63, tell OpenGL that we wish to draw in the entire
  framebuffer

* On line 64, since the frame is about to be drawn, make it a blank slate.
  The color of each pixel will be the clear color.
  Programming in OpenGL is a bit different than normal programming,
  in that individual function calls do not always do everything you need
  in isolation.  Instead, they mutate state, which may require
  multiple function calls to complete a certain task.

* Nothing will be rendered, so nothing to do

* On Line 65, we are done with the frame, flush the frame to
  the monitor, and swap the back and front buffers



Black Screen
^^^^^^^^^^^^

Type "python demo.py", or "python3 demo.py" to run.

The first demo is the least interesting graphical program possible.

#. Sets the color at every pixel black.  (A constant color is better than whatever
   color happened to be the previous time it was drawn.)

#. If the user resized the window, reset OpenGL's mappings from *normalized-device-coordinates*
   to *screen-coordinates*.

#. Cleared the depth buffer (don't worry about this for now).

When this code returns, the event loop flushes (i.e) sends the frame to the monitor.  Since
no geometry was drawn, the color value for each pixel is still black.

Each color is represented by a number, so the frame is something like this ::

    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

The event loop then calls this code over and over again, and since we retain no state and
we draw nothing, a black screen will be displayed every frame until the user
closes the window, and says to himself, "why did I buy Doom 3"?
