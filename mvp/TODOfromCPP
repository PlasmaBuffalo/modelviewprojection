//[source,C,linenums]
//----
  }
//----
//[source,C,linenums]
//----
  if(14 == *chapter_number){
    draw_in_square_viewport();
//----
//Draw paddle 1, relative to the world-space origin.
//[source,C,linenums]
//----
    glColor3f(/*red*/   1.0,
              /*green*/ 1.0,
              /*blue*/  1.0);
    glBegin(GL_QUADS);
    {
      for(Vertex3 modelspace : paddle3D){
        Vertex3 worldSpace = modelspace
          .rotateZ(/*radians*/ paddle_1_rotation)
          .translate(/*x*/ -90.0,
                     /*y*/ paddle_1_offset_Y,
                     /*z*/ 0.0);
        // new camera transformations
        Vertex3 cameraSpace = worldSpace
          .translate(/*x*/ -moving_camera_x,      // NEW
                     /*y*/ -moving_camera_y,      // NEW
                     /*z*/ -moving_camera_z)      // NEW
          .rotateY(/*radians*/ -moving_camera_rot_y)    // NEW
          .rotateX(/*radians*/ -moving_camera_rot_x);   // NEW
        // end new camera transformations
////TODO -  discuss order of rotations, use moving head analogy to show that rotations are not commutative
        Vertex3 ndcSpace = cameraSpace
          .ortho(/*min_x*/ -100.0f,
                 /*max_x*/ 100.0f,
                 /*min_y*/ -100.0f,
                 /*max_y*/ 100.0f,
                 /*min_z*/ 100.0f,
                 /*max_z*/ -100.0f);
        glVertex3f(/*x*/ ndcSpace.x,
                   /*y*/ ndcSpace.y,
                   /*z*/ ndcSpace.z);
      }
    }
    glEnd();
//----
//Draw square, relative to paddle 1.
//[source,C,linenums]
//----
    glColor3f(/*red*/   0.0,
              /*green*/ 0.0,
              /*blue*/  1.0);
    glBegin(GL_QUADS);
    {
      for(Vertex3 modelspace : square3D){
        Vertex3 worldSpace = modelspace
          .rotateZ(/*radians*/ square_rotation)
          .translate(/*x*/ 20.0f,
                     /*y*/ 0.0f,
                     /*z*/ -10.0f)  // NEW, using a different Z value
          .rotateZ(/*radians*/ rotation_around_paddle_1)
          .rotateZ(/*radians*/ paddle_1_rotation)
          .translate(/*x*/ -90.0,
                     /*y*/ paddle_1_offset_Y,
                     /*z*/ 0.0);
        // new camera transformations
        Vertex3 cameraSpace = worldSpace
          .translate(/*x*/ -moving_camera_x,      // NEW
                     /*y*/ -moving_camera_y,      // NEW
                     /*z*/ -moving_camera_z)      // NEW
          .rotateY(/*radians*/ -moving_camera_rot_y)    // NEW
          .rotateX(/*radians*/ -moving_camera_rot_x);   // NEW
        // end new camera transformations
        Vertex3 ndcSpace = cameraSpace
          .ortho(/*min_x*/ -100.0f,
                 /*max_x*/ 100.0f,
                 /*min_y*/ -100.0f,
                 /*max_y*/ 100.0f,
                 /*min_z*/ 100.0f,
                 /*max_z*/ -100.0f);
        glVertex3f(/*x*/ ndcSpace.x,
                   /*y*/ ndcSpace.y,
                   /*z*/ ndcSpace.z);
      }
      glEnd();
    }
//----
//Draw paddle 2, relative to the world-space origin.
//[source,C,linenums]
//----
    glBegin(GL_QUADS);
    {
      glColor3f(/*red*/   1.0,
                /*green*/ 1.0,
                /*blue*/  0.0);
      for(Vertex3 modelspace : paddle3D){
        Vertex3 worldSpace = modelspace
          .rotateZ(/*radians*/ paddle_2_rotation)
          .translate(/*x*/ 90.0,
                     /*y*/ paddle_2_offset_Y,
                     /*z*/ 0.0);
        // new camera transformations
        Vertex3 cameraSpace = worldSpace
          .translate(/*x*/ -moving_camera_x,      // NEW
                     /*y*/ -moving_camera_y,      // NEW
                     /*z*/ -moving_camera_z)      // NEW
          .rotateY(/*radians*/ -moving_camera_rot_y)    // NEW
          .rotateX(/*radians*/ -moving_camera_rot_x);   // NEW
        // end new camera transformations
        Vertex3 ndcSpace = cameraSpace
          .ortho(/*min_x*/ -100.0f,
                 /*max_x*/ 100.0f,
                 /*min_y*/ -100.0f,
                 /*max_y*/ 100.0f,
                 /*min_z*/ 100.0f,
                 /*max_z*/ -100.0f);
        glVertex3f(/*x*/ ndcSpace.x,
                   /*y*/ ndcSpace.y,
                   /*z*/ ndcSpace.z);
      }
    }
    glEnd();
    return;
  }

////TODO - discuss the framebuffer, and how it allows us to draw in
////       a depth-independent manner.  we could force the programmer
////       to sort objects by depth before drawing, but that's why mario64
////       looked good and crash bandicoot had limited perspectives.
////       also reference the section in the beginning which clears the
////       depth buffer.

//----
//== Considering Depth
//[source,C,linenums]
//----
  if(*chapter_number >= 15){
    glEnable(GL_DEPTH_TEST);
  }
////TODO - write something about how "now that depth testing is enabled for all subequent demos, rerun the##//vious demo to show that the square becomes hidden as the user navigates

  if(15 == *chapter_number){
    *chapter_number = 14;
    return;
  }
//----
//== Perspective Viewing


////TODO -  make a new chapter which uses perspective, but
////        doesn't use lambdas
////TODO -  afterwards, in this chapter, explain perspective
////TODO -  use graphviz to show the stack of transforamations.
////        combine them into a tree.
////        talk about how how I used to think that the important
////        "objects" were the vertices, colors, etc, but the important
////        concept is relative spaces, i.e. the coordinate frame of references.
////
////        Since it's a stack, the last operator is pushed first, but applied last.
////        This means that transformations need to be "read" backwards to understand
////        what's happening.

//[source,C,linenums]
//----
  if(*chapter_number >= 16){
    static bool first_frame = true;
    if(first_frame){
      moving_camera_z = 400.0; // for the perspective to look right
      first_frame = false;
    }
  }
//----
//[source,C,linenums]
//----
  // use stacks for transformations
  std::vector<Vertex3_transformer> transformationStack;
  Vertex3_transformer withTransformations = [&](Vertex3 v){
    Vertex3 result = v;
    for(std::vector<Vertex3_transformer>::reverse_iterator
          rit = transformationStack.rbegin();
        rit!=transformationStack.rend();
        rit++)
      {
        result = (*rit)(result);
      }
    return result;
  };
//----


//[source,C,linenums]
//----
  if(16 == *chapter_number){
    // every shape is projected the same way
    transformationStack.push_back([&](Vertex3 v){
        return v.perspective(-0.1f,
                             -1000.0f);
      });
    // THE REST IS THE SAME AS THE PREVIOUS
    // every shape is relative to the camera
    // camera transformation #3 - tilt your head down
    transformationStack.push_back([&](Vertex3 v){
        return v.rotateX(/*radians*/ -moving_camera_rot_x);
      });
    // camera transformation #2 - turn your head to the side
    transformationStack.push_back([&](Vertex3 v){
        return v.rotateY(/*radians*/ -moving_camera_rot_y);
      });
    // camera transformation #1 - move to the origin
    transformationStack.push_back([&](Vertex3 v){
        return v.translate(/*x*/ - moving_camera_x,
                           /*y*/ - moving_camera_y,
                           /*z*/ - moving_camera_z);
      });
    transformationStack.push_back([&](Vertex3 v){
        return v.translate(/*x*/ -90.0f,
                           /*y*/ 0.0f + paddle_1_offset_Y,
                           /*z*/ 0.0f);
      });
//----
//Draw paddle 1, relative to the world-space origin.
//[source,C,linenums]
//----
    glColor3f(/*red*/   1.0,
              /*green*/ 1.0,
              /*blue*/  1.0);
    transformationStack.push_back([&](Vertex3 v){
        return v.rotateZ(/*radians*/ paddle_1_rotation);
      });
    transformationStack.push_back([&](Vertex3 v){
        return v.scale(/*x*/ 10.0f,
                       /*y*/ 30.0f,
                       /*z*/ 1.0f);
      });
    draw_square3_programmable(withTransformations);
    transformationStack.pop_back();
    transformationStack.pop_back();
//----
//Draw square, relative to paddle 1.
//[source,C,linenums]
//----
    glColor3f(/*red*/   0.0,
              /*green*/ 0.0,
              /*blue*/  1.0);
    {
      transformationStack.push_back([&](Vertex3 v){
          return v.rotateZ(/*radians*/ paddle_1_rotation);
        });
      transformationStack.push_back([&](Vertex3 v){
          return v.rotateZ(/*radians*/ rotation_around_paddle_1);
        });
      transformationStack.push_back([&](Vertex3 v){
          return v.translate(/*x*/ 20.0f,
                             /*y*/ 0.0f,
                             /*z*/ -10.0f); // NEW, using a non zero
        });
      transformationStack.push_back([&](Vertex3 v){
          return v.rotateZ(/*radians*/ square_rotation);
        });
      transformationStack.push_back([&](Vertex3 v){
          return v.scale(/*x*/ 5.0f,
                         /*y*/ 5.0f,
                         /*z*/ 1.0f);
        });
      draw_square3_programmable(withTransformations);
      transformationStack.pop_back();
      transformationStack.pop_back();
      transformationStack.pop_back();
      transformationStack.pop_back();
      transformationStack.pop_back();
    }
    // get back to the world-space origin
    transformationStack.pop_back();
//----
//Draw paddle 2, relative to the world-space origin.
//[source,C,linenums]
//----
    glColor3f(/*red*/   1.0,
              /*green*/ 1.0,
              /*blue*/  0.0);
    transformationStack.push_back([&](Vertex3 v){
        return v.translate(/*x*/ 90.0f,
                           /*y*/ 0.0f + paddle_2_offset_Y,
                           /*z*/ 0.0f);
      });
    transformationStack.push_back([&](Vertex3 v){
        return v.rotateZ(/*radians*/ paddle_2_rotation);
      });
    transformationStack.push_back([&](Vertex3 v){
        return v.scale(/*x*/ 10.0f,
                       /*y*/ 30.0f,
                       /*z*/ 1.0f);
      });
    draw_square3_programmable(withTransformations);
    transformationStack.pop_back();
    transformationStack.pop_back();
    transformationStack.pop_back();
    transformationStack.pop_back();
    transformationStack.pop_back();
    transformationStack.pop_back();
    transformationStack.pop_back();
    return;
  }
//----
//== OpenGL 2.0 Matricies
//[source,C,linenums]
//----
  if(*chapter_number >= 17){
////TODO - discuss that OpenGL uses left hand rule by default, so Z
////TODO - into the screen is positive.  I don't know why that is,
////TODO - but perhaps it is to save a bit since you're never gonna look at stuff behind you
    glClearDepth(1.1f );
    glDepthFunc(GL_LEQUAL);
  }
//----
//[source,C,linenums]
//----
  std::function<void()> draw_square_opengl2point1 = [&](){
    glBegin(GL_QUADS);
    {
      glVertex2f(/*x*/ -1.0,
                 /*y*/ -1.0);
      glVertex2f(/*x*/ 1.0,
                 /*y*/ -1.0);
      glVertex2f(/*x*/ 1.0,
                 /*y*/ 1.0);
      glVertex2f(/*x*/ -1.0,
                 /*y*/ 1.0);
    }
    glEnd();
  };
//----
////TODO - describe matricies as efficient substitions for our vertex transforamiotns.
////TODO - describe how they act as a stack, similarly to how was done in the above.
//[source,C,linenums]
//----
  if(17 == *chapter_number){
    /*
     *  Demo 17 - OpenGL 1.4 Matricies
     */
    // set up Camera
    {
      // define the projection
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
      {
        int w, h;
        glfwGetFramebufferSize(window, &w, &h);
        gluPerspective(45.0f,
                       (GLdouble)w / (GLdouble)h,
                       0.1f,
                       1000.0f);
      }
      // move the "camera"
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();
////TODO - describe how these matrix rotations act on arbitrary axises, not just XYZ
      glRotatef(/*degrees*/ RAD_TO_DEG(-moving_camera_rot_x),
                /*x*/ 1.0,
                /*y*/ 0.0,
                /*z*/ 0.0);
      glRotatef(/*degrees*/ RAD_TO_DEG(-moving_camera_rot_y),
                /*x*/ 0.0,
                /*y*/ 1.0,
                /*z*/ 0.0);
      glTranslatef(/*x*/ -moving_camera_x,
                   /*y*/ -moving_camera_y,
                   /*z*/ -moving_camera_z);
    }
//----
//Draw paddle 1, relative to the world-space origin.
//[source,C,linenums]
//----
    glPushMatrix();
    glColor3f(/*red*/   1.0,
              /*green*/ 1.0,
              /*blue*/  1.0);
    glTranslatef(/*x*/ -90.0f,
                 /*y*/ 0.0f + paddle_1_offset_Y,
                 /*z*/ 0.0);
    glRotatef(/*degrees*/ RAD_TO_DEG(paddle_1_rotation),
              /*x*/ 0.0,
              /*y*/ 0.0,
              /*z*/ 1.0);
    // scaling of this object should not affect the relative square
    glPushMatrix();
    {
      glScalef(/*x*/ 10.0f,
               /*y*/ 30.0f,
               /*z*/ 1.0f);
      draw_square_opengl2point1();
      glPopMatrix();
    }
//----
//Draw square, relative to paddle 1.
//[source,C,linenums]
//----
    glColor3f(/*red*/   0.0,
              /*green*/ 0.0,
              /*blue*/  1.0);
    glRotatef(/*degrees*/ RAD_TO_DEG(rotation_around_paddle_1),
              /*x*/ 0.0f,
              /*y*/ 0.0f,
              /*z*/ 1.0f);
    glTranslatef(/*x*/ 20.0f,
                 /*y*/ 0.0f,
                 /*z*/ -10.0f);
    glRotatef(/*degrees*/ RAD_TO_DEG(square_rotation),
              /*x*/ 0.0f,
              /*y*/ 0.0f,
              /*z*/ 1.0f);
    glScalef(/*x*/ 5.0f,
             /*y*/ 5.0f,
             /*z*/ 5.0f);
    draw_square_opengl2point1();
    glPopMatrix();
//----
//Draw paddle 2, relative to the world-space origin.
//[source,C,linenums]
//----
    glPushMatrix();
    glColor3f(/*red*/   1.0,
              /*green*/ 1.0,
              /*blue*/  0.0);
    glTranslatef(/*x*/ 90.0f,
                 /*y*/ 0.0f + paddle_2_offset_Y,
                 /*z*/ 0.0);
    glRotatef(/*degrees*/ RAD_TO_DEG(paddle_2_rotation),
              /*x*/ 0.0,
              /*y*/ 0.0,
              /*z*/ 1.0);
    glScalef(/*x*/ 10.0f,
             /*y*/ 30.0f,
             /*z*/ 1.0f);
    draw_square_opengl2point1();
    glPopMatrix();
    return;
  }
  // in later demos,
  //glClearDepth(1.0f );
  //glEnable(GL_DEPTH_TEST );
  //glDepthFunc(GL_LEQUAL );
  return;
}
//----
//
//[[sharedLibAppendix]]
//[appendix]
//== Shared Libraries
//
//Foo bar baz2
//
//
//[bibliography]
//Example Bibliography
//--------------------
//The bibliography list is a style of AsciiDoc bulleted list.
//
//[bibliography]
//.Books
//- [[[taoup]]] Eric Steven Raymond. 'The Art of Unix
//  Programming'. Addison-Wesley. ISBN 0-13-142901-9.
//  - [[[walsh-muellner]]] Norman Walsh & Leonard Muellner.
//    'DocBook - The Definitive Guide'. O'Reilly & Associates. 1999.
//      ISBN 1-56592-580-7.
//
//[bibliography]
//.Articles
//- [[[abc2003]]] Gall Anonim. 'An article', Whatever. 2003.
//
//
//[glossary]
//Example Glossary
//----------------
//Glossaries are optional. Glossaries entries are an example of a style
//of AsciiDoc labeled lists.
//
//[glossary]
//A glossary term::
//  The corresponding (indented) definition.
//
//A second glossary term::
//  The corresponding (indented) definition.
//
//
//[colophon]
//Example Colophon
//----------------
//Text at the end of a book describing facts about its production.
//
//
//[index]
//Example Index
//-------------
//////////////////////////////////////////////////////////////////
//The index is normally left completely empty, it's contents being
//generated automatically by the DocBook toolchain.
//////////////////////////////////////////////////////////////////
