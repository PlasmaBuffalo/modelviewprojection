// The MIT License (MIT)
//
// Copyright (c) 2017-2018 William Emerison Six
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

= Model View Projection
:author: Bill Six <billsix@gmail.com>
:doctype: book
:toc:

[dedication]
= Dedication

To Teresa, Liam, Adam, and Kate.
















== Keeping the Paddles Proportional

=== Create procedure to ensure proportionality
In the previous chapter, if the user resized the window, the paddles looked bad,
as they were shrunk in one direction if the window became too thin or too fat.


image:disproportionate1.png[align="center",title="Foo"]


image:disproportionate2.png[align="center",title="Foo"]


Assume that this is a problem for the application we are making.  What
would a solution be?  Ideally, we would like to draw our paddles with
a black background within a square region in the center of the window, regardless of the dimensions
of the window.

OpenGL has a solution for us.  The *viewport* is a rectangular region
within the window into which OpenGL will render.  The normalized-device-coordinates
will therefore resolve to the sub-screen space of the viewport, instead of the whole
window.


image:viewport.png[align="center",title="Programming using Screen Space on Large Monitor"]

Because we will only draw in a subset of the window, and because all subsequent
chapters will use this functionality, I have created a procedure for use
in all chapters. "draw_in_square_viewport" is a C++ lambda, which just
means that it's a procedure defined at runtime.  Don't worry about the details
of lambdas, just know that the following two types are the same:





=== Set the viewport, and then execute the code from chapter 3.



== Move the Paddles using the Keyboard

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|*w*              |*Move Left Paddle Up*
|*s*              |*Move Left Paddle Down*
|*k*              |*Move Right Paddle Up*
|*i*              |*Move Right Paddle Down*
|=======================================
Paddles which don't move are quite boring.  Let's make them move up or down
by getting keyboard input.




Define a draw method on the Paddle class.  Python allows
both instance variables and methods to be added to a class
after it has already been defined.  Although the author
doesn't recommend cavalier use of this concept, graphics
are best explained incrementally, and the dynamic features
of Python help towards this goal.




-If 's' is pressed this frame, subtract 0.1 more from paddle1.offsetY.  If the
key continues to be held down over time, paddle1.offsetY will continue to decrease.

-If 'w' is pressed this frame, add 0.1 more to paddle1.offsetY.

-If 'k' is pressed this frame, subtract 0.1 more from paddle_2_offset_Y.

-If 'i' is pressed this frame, add 0.1 more to paddle_2_offset_Y.

Remember, these are static variables, so changes to these variables will
accumulate across frames.





Draw paddle 1, relative to the world-space origin.
Add paddle1.offsetY to the "y" component of every vertex


image:plot3.png[align="center",title="Foo"]


Draw paddle 2, relative to the world-space origin.
Add paddle_2_offset_Y to the "y" component of every vertex



image:plot4.png[align="center",title="Foo"]


== Translation

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|=======================================

Transforming vertices, such as translating, is the core concept
of computer graphics.



=== Translation
Rather than incrementing y values before calling "glVertex",
instead call "translate" on the vertex, and call "glVertex2f"
on the translated vertex.

image:translationF.gif[align="center",title="Foo"]


== Model-space

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|=======================================

Normalized-device-coordinates are not a natural system of
numbers for use by humans.  Imagine that the paddles in the previous
chapters exist in real life, and are 20 meters wide and 60 meters tall.
The graphics programmer should be able to use those numbers directly;
they shouldn't have to manually trasform the distances into normalized-device-coordinates.

Whatever a convenient numbering system is (i.e. coordinate system) for modeling objects
is called "model-space".  Since a paddle has four corners, which corner should be a
the origin (0,0)?  If you don't already know what you want at the origin, then
none of the corners should be; instead put the center of the object
at the originfootnote:[By putting the center of the object at the origin,
scaling and rotating the object are trivial].

image:modelspace.png[align="center",title="Foo"]



Model-space to World-space.

You can view the transformations from first transformation to last,
where all transformations happen relative to the world-space origin.
(this works well for world-space to camera-space,
but not so well for model-space transformations)

image:translation2F.gif[align="center",title="Foo"]


Instead, for model-space to world-space transformations (and for these transformations only),
it's easier to read the transformations backwards, where the transformations
aren't relative to the global origin, instead it's from the local frame of reference.


image:translation2B.gif[align="center",title="Foo"]



Why do the two different views of the transformations matter?  In model-space
to world-space transformations, especially once rotation and scaling of model-space
is used, it allows the programmer to forget about most details, just specify
where new objects are relative to that which you are already drawing.

With that said, that doesn't mean that reading the transformations front to back
has no value.  But it only has value in world-space to camera-space conversions,
and from camera-space to ndc-space.

This will make more sense once rotation is involved.




=== Scaling

image:scale.png[align="center",title="Foo"]


Similarly, we can expand or shrink the size of an object
by "scale"ing each of the vertices of the object, assuming
the object's center is at (0,0).



image:modelspacePaddle7.png[align="center",title="Foo"]

#World-space to NDC-space.

image:modelspacePaddle8.png[align="center",title="Foo"]




=== Rotation Around Origin (0,0)

We can also rotate an object around (0,0) by rotating
all of the object's vertices around (0,0).  Although defined now,
this won't
be used until later.

In high school math, you will have learned about sin, cos, and tangent.
Typically the angles are described on the unit circle, where a rotation
starts from the positive x axis.  We can expand on this knowledge, allowing
us to rotate a given vertex around the origin (0,0).  This is done
by separating the x and y value, rotating each of them seperately,
and then adding the results together.

That might not have been fully clear.  Let me try again.
The vertex (0.5,0.4) can be separated into two vertices, (0.5,0) and (0,0.4).

image:rotate3.png[align="center",title="Foo"]

image:rotate4.png[align="center",title="Foo"]


These vertices can be added together to create the original vertex.
But, before we do that, let's rotate each of the vertices.

(0.5,0) is on the x-axis, so rotating it by "angle" degrees, results
in vertex (0.5*cos(angle), 0.5*sin(angle)).  Notice that both the x and
y values are multiplied by 0.5.  This is because rotations should not affect
the distance of the point from the origin (0,0).  (0.5,0) has length 0.5.
(cos(angle), sin(angle) has length 1. By multipling both the x and y
component by 0.5, we are scaling the vertex back to its original distance
from the origin.

image:rotate.png[align="center",title="Foo"]

(0,0.4) is on the y-axis, so rotating it by "angle" degrees, results
in vertex (0.4*-sin(angle), 0.4*cos(angle)).

image:rotate2.png[align="center",title="Foo"]

Wait.  Why is negative
sin applied to the angle to make the x value, and cos applied to angle to make the y value?
Trigonometric operations such as sin, cos, and tangent assume that the rotation is happening on
the unit circle, starting from (1,0) on the x axis.  Since we want
to rotate an angle starting from (0,1) on the y axis, we sin and
cos must be swapped.  Sin is positive from 0 to 90 degrees, but
we want a negative value for our rotation of the y axis since the rotation is happening counter-clockwise,
hence the negative sin.



After the rotations have been applied, sum the results to
get your vertex rotated around the origin!

(0.5*cos(angle), 0.5*sin(angle)) + (0.4*-sin(angle), 0.4*cos(angle)) =
(0.5*cos(angle) + 0.4*-sin(angle), 0.5*sin(angle) + 0.4*cos(angle))







== Rotate the Paddles About their Center

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|               |
|*d*              |*Increase Left Paddle's Rotation*
|*a*              |*Decrease Left Paddle's Rotation*
|*l*              |*Increase Right Paddle's Rotation*
|*j*              |*Decrease Right Paddle's Rotation*
|=======================================

# TODO - describe angle as radians
# TODO - show unit circle
# TODO - show orthonormal basis
# TODO - show basic proof of rotate

TODO - Explain how this does not do what we want.  Show example graphs.




 TODO - explain that translate each points and the origin.  We then rotate around the new origin
 by translating back to the global origin, doing the rotation, and then redoing the translation.
 Regardless of the inefficiency of this calculation, it should be clear to the reader
 that we are not thinking about this correctly.  The initial translate is effectively canceled out,
 leaving a rotation and then a translation.



image:rotation1F.gif[align="center",title="Foo"]

image:rotation1B.gif[align="center",title="Foo"]

image:rotation2F.gif[align="center",title="Foo"]

image:rotation2B.gif[align="center",title="Foo"]





== Camera Management

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|               |
|d              |Increase Left Paddle's Rotation
|a              |Decrease Left Paddle's Rotation
|l              |Increase Right Paddle's Rotation
|j              |Decrease Right Paddle's Rotation
|               |
|*UP*             |*Move the Camera Up*
|*DOWN*           |*Move the Camera Down*
|*LEFT*           |*Move the Camera Left*
|*RIGHT*          |*Move the Camera Right*
|=======================================

# TODO - describe implicit camera at origin, and making it's location explicit
# TODO - descriibe desire for moving camera



== Relative Objects

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|               |
|d              |Increase Left Paddle's Rotation
|a              |Decrease Left Paddle's Rotation
|l              |Increase Right Paddle's Rotation
|j              |Decrease Right Paddle's Rotation
|               |
|UP             |Move the Camera Up
|DOWN           |Move the Camera Down
|LEFT           |Move the Camera Left
|RIGHT          |Move the Camera Right
|               |
|=======================================



== Rotate the Square About Its Origin

[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|               |
|d              |Increase Left Paddle's Rotation
|a              |Decrease Left Paddle's Rotation
|l              |Increase Right Paddle's Rotation
|j              |Decrease Right Paddle's Rotation
|               |
|UP             |Move the Camera Up
|DOWN           |Move the Camera Down
|LEFT           |Move the Camera Left
|RIGHT          |Move the Camera Right
|               |
|*q*              |*Rotate the square around its center.*
|=======================================


== Relative Rotation
[width="75%",options="header,footer"]
|=======================================
|Keyboard Input |Action
|w              |Move Left Paddle Up
|s              |Move Left Paddle Down
|k              |Move Right Paddle Up
|i              |Move Right Paddle Down
|               |
|d              |Increase Left Paddle's Rotation
|a              |Decrease Left Paddle's Rotation
|l              |Increase Right Paddle's Rotation
|j              |Decrease Right Paddle's Rotation
|               |
|UP             |Move the Camera Up
|DOWN           |Move the Camera Down
|LEFT           |Move the Camera Left
|RIGHT          |Move the Camera Right
|               |
|q              |Rotate the square around its center
|*e*              |*Rotate the square around the left paddle*
|=======================================



== Adding Depth
//TODO - discuss what the z component is, show graphs.
//TODO - show X, Y, and Z rotations graphically with gnuplot.
//TODO - make appendix for rotation around arbitrary axis

== Moving the Camera in 3D



// TODO -- draw_paddle_1 is still using only 2D, explain implicit 3D of z have 0 for a value
Draw square, relative to paddle 1.


TODO - discuss the framebuffer, and how it allows us to draw in
       a depth-independent manner.  we could force the programmer
       to sort objects by depth before drawing, but that's why mario64
       looked good and crash bandicoot had limited perspectives.
       also reference the section in the beginning which clears the
       depth buffer.


Set the default depth for all fragments
Set the depth test for all fragments.



TODO - write something about how "now that depth testing is enabled for all subequent demos, rerun the//vious demo to show that the square becomes hidden as the user navigates
